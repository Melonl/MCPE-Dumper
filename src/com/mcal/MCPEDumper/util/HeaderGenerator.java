package com.mcal.MCPEDumper.util;
import com.mcal.MCPEDumper.nativeapi.*;
import java.util.*;
import com.mcal.MCPEDumper.*;

public class HeaderGenerator
{
	private MCPEClass mcpeClass;
	private MCPEVtable vtable;
	private String[] namespace;
	private String className;

	public HeaderGenerator(MCPEClass mcpeClass, MCPEVtable vtable)
	{
		this.mcpeClass = mcpeClass;
		this.vtable = vtable;
		
		this.className = mcpeClass.getName().substring(mcpeClass.getName().lastIndexOf("::")+1,mcpeClass.getName().length());
		try
		{
			String namespaces = mcpeClass.getName().substring(0,mcpeClass.getName().length()-className.length()-1);
			if(namespaces==null)
				this.namespace = new String[0];
			else
				this.namespace = namespaces.split("::");
		}
		catch(Exception e)
		{
			this.namespace = new String[0];
			e.printStackTrace();
		}
	}

	public String[] generate()
	{
		Vector<String> lines=new Vector<String>();
		try
		{
			lines.addElement("#pragma once");
			lines.addElement("");
			lines.addElement("//This header template file is generated by MCPE-Dumper.");
			lines.addElement("");
			
			for(String space:namespace)
			{
				lines.addElement("namespace "+space);
				lines.addElement("{");
			}
			
			lines.addElement("class " + mcpeClass.getName());
			lines.addElement("{");
			lines.addElement("public:");
			lines.addElement("	//Fields");
			lines.addElement("	char filler_"+className+"[UNKNOW_SIZE];");
			
			if (getVtables() != null)
			{
				lines.addElement("public:");
				lines.addElement("	//Virtual Tables");
				
				for (MCPESymbol symbol:getVtables())
				{
					try
					{
						String mname=getVirtualMethodDefinition(symbol);
						lines.addElement("	" + mname);
					}
					catch(Exception e){}
				}
			}
			
			if (getMethods() != null)
			{
				lines.addElement("public:");
				lines.addElement("	//Methods");
				
				for (MCPESymbol symbol:getMethods())
				{
					String mname=getMethodDefinition(symbol);
					lines.addElement("	" + mname);
				}
			}
			
			if (getObjects() != null)
			{
				lines.addElement("public:");
				lines.addElement("	//Objects");
				for (MCPESymbol symbol:getObjects())
				{
					String mname=getObjectDefinition(symbol);
					lines.addElement("	" + mname);
				}
			}
			lines.addElement("};//"+className);
			for(String space:namespace)
			{
				lines.addElement("}//"+space);
			}
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		String[] ret=new String[lines.size()];
		for (int i=0;i < lines.size();++i)
			ret[i] = lines.get(i);
		return ret;
	}

	private String getObjectDefinition(MCPESymbol symbol)
	{
		String name=symbol.getDemangledName().substring(mcpeClass.getName().length()+2, symbol.getDemangledName().length());
		return "static " + mcpeClass.getName() + " * " + name + ";";
	}

	private String getMethodDefinition(MCPESymbol symbol)
	{
		String name=symbol.getDemangledName().substring(mcpeClass.getName().length()+2, symbol.getDemangledName().length());
		if(name.startsWith("~"+className))
			return name + ";";
		if(name.startsWith(className))
			return name + ";";
		return "void " + name + ";";
	}
	
	private String getVirtualMethodDefinition(MCPESymbol symbol)throws Exception
	{
		String name_=symbol.getDemangledName();
		if(!name_.startsWith(mcpeClass.getName()))
			throw new Exception("No owned vtable");
		String name=symbol.getDemangledName().substring(mcpeClass.getName().length()+2, symbol.getDemangledName().length());
		if(name.startsWith("~"+className))
			return "virtual " + name + ";";
		if(name.startsWith(className))
			return "virtual " + name + ";";
		return "virtual void " + name + ";";
	}

	private MCPESymbol[] getObjects()
	{
		Vector<MCPESymbol>symbols=new Vector<MCPESymbol>();
		for (MCPESymbol symbol:mcpeClass.getSymbols())
			if (isObjectItem(symbol))
				symbols.addElement(symbol);
		MCPESymbol[] ret=new MCPESymbol[symbols.size()];
		for (int i=0;i < symbols.size();++i)
			ret[i] = symbols.get(i);
		if (symbols.isEmpty())
			return null;
		return ret;
	}
	
	private MCPESymbol[] getVtables()
	{
		if(vtable==null)
			return null;
		if (vtable.getVtables().isEmpty())
			return null;
		MCPESymbol[] ret=new MCPESymbol[vtable.getVtables().size()];
		for (int i=0;i < vtable.getVtables().size();++i)
			ret[i] = vtable.getVtables().get(i);
		
		return ret;
	}

	private MCPESymbol[] getMethods()
	{
		Vector<MCPESymbol>symbols=new Vector<MCPESymbol>();
		for (MCPESymbol symbol:mcpeClass.getSymbols())
			if (isMethodItem(symbol)&&!isVtable(symbol))
				symbols.addElement(symbol);
		if (symbols.isEmpty())
			return null;
		MCPESymbol[] ret=new MCPESymbol[symbols.size()];
		for (int i=0;i < symbols.size();++i)
			ret[i] = symbols.get(i);
		return ret;
	}
	
	private boolean isVtable(MCPESymbol sym)
	{
		if(vtable==null)
			return false;
		for(MCPESymbol symbol:vtable.getVtables())
			if(symbol.equals(sym))
				return true;
		return false;
	}

	private static boolean isObjectItem(MCPESymbol sym)
	{
		String dname=sym.getDemangledName();
		String name=sym.getName();
		if(dname.indexOf("(")==-1&&dname.indexOf(")")==-1&&name.startsWith("_ZN"))
			return true;
		return false;
	}

	private static boolean isMethodItem(MCPESymbol sym)
	{
		String dname=sym.getDemangledName();
		String name=sym.getName();
		if(dname.indexOf("(")!=-1&&dname.indexOf(")")!=-1&&name.startsWith("_ZN"))
			return true;
		return false;
	}
}
