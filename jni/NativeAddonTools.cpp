#include <jni.h>
#include <fstream>
#include <string>
#include <vector>
#include <cxxabi.h>
#include <sys/stat.h>

std::string jstringTostring(JNIEnv* env, jstring jstr)
{
	char* rtn = NULL;
	jclass clsstring = env->FindClass("java/lang/String");
	jstring strencode = env->NewStringUTF("GB2312");
	jmethodID mid = env->GetMethodID(clsstring, "getBytes", "(Ljava/lang/String;)[B");
	jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr,mid,strencode);
	jsize alen = env->GetArrayLength(barr);
	jbyte* ba = env->GetByteArrayElements(barr,JNI_FALSE);
	if(alen > 0)
	{
		rtn = (char*)malloc(alen+1);
		memcpy(rtn,ba,alen);
		rtn[alen]=0;
	}
	env->ReleaseByteArrayElements(barr,ba,0);
	std::string stemp(rtn);
	free(rtn);
	return stemp;
}

extern "C"
{
JNIEXPORT jboolean JNICALL Java_com_MCAL_NativeAddonTools_NativeAddonTools_hasFile(JNIEnv* env, jobject thiz,jstring path)
{
	std::ifstream istream(jstringTostring(env,path).c_str());
	return istream.is_open();
}
JNIEXPORT void JNICALL Java_com_MCAL_NativeAddonTools_NativeAddonTools_generateMethodTable(JNIEnv* env, jobject thiz,jstring path,jstring outDemangled,jstring outUndemangled,jboolean useLine)
{
	std::string filePath=jstringTostring(env,path);
	std::string outUndemangledPath=jstringTostring(env,outUndemangled);
	std::string outDemangledPath=jstringTostring(env,outDemangled);
	
	std::ifstream istream(filePath.c_str());
	std::vector<char> letters;
	std::string bridgeString;
	unsigned long counter=0;
	std::vector<std::string>strings;
	if(!istream.is_open())
		return;
	while(!istream.eof())
	{
		char letter;
		istream.get(letter);
		letters.push_back(letter);
	}
	for(char letter:letters)
	{
		if(letter=='\n'||letter==' ')
			continue;
		if(letter=='_')
		{
			strings.push_back(bridgeString);
			bridgeString="";
		}
		bridgeString+=letter;
	}
	if(!bridgeString.empty())
		strings.push_back(bridgeString);
	
	mkdir(outUndemangledPath.substr(0,outUndemangledPath.find_last_of("/")).c_str(),0);
	mkdir(outDemangledPath.substr(0,outDemangledPath.find_last_of("/")).c_str(),0);
	std::ofstream ostream(outUndemangledPath.c_str());
	std::ofstream ostream_demangled(outDemangledPath.c_str());
	
	ostream<<"---------------------------------------------"<<std::endl;
	ostream<<"This file is generated by Method Table Generator(com.MCAL.NativeAddonTools)."<<std::endl;
	ostream<<"---------------------------------------------"<<std::endl;
	ostream_demangled<<"---------------------------------------------"<<std::endl;
	ostream_demangled<<"This file is generated by Method Table Generator(com.MCAL.NativeAddonTools)."<<std::endl;
	ostream_demangled<<"---------------------------------------------"<<std::endl;
	
	for(std::string string:strings)
	{
		while(!string.empty())
		{
			if(string[0]!='_'||string[1]!='Z')
				goto next;
			if(abi::__cxa_demangle(string.c_str(),0,0,0))
			{
				if(useLine)
				{
					ostream_demangled<<"/*"<<++counter<<"*/"<<abi::__cxa_demangle(string.c_str(),0,0,0)<<std::endl;
					ostream<<"/*"<<counter<<"*/"<<string<<std::endl;
				}
				else
				{
					ostream_demangled<<abi::__cxa_demangle(string.c_str(),0,0,0)<<std::endl;
					ostream<<string<<std::endl;
				}
				goto next;
			}
			else
				string=string.substr(0,string.length()-1);
		}
		next:;
	}
}
JNIEXPORT jstring JNICALL Java_com_MCAL_NativeAddonTools_NativeAddonTools_demangleName(JNIEnv* env, jobject thiz,jstring name)
{
	std::string methodsName=jstringTostring(env,name);
	
	std::string bridgeString;
	std::vector<std::string>strings;
	std::string result;
	
	for(char letter:methodsName)
	{
		if(letter=='\n'&&!bridgeString.empty())
		{
			strings.push_back(bridgeString);
			bridgeString="";
		}
		else bridgeString+=letter;
	}
	if(!bridgeString.empty())
		strings.push_back(bridgeString);
	
	for(std::string string:strings)
	{
		if(abi::__cxa_demangle(string.c_str(),0,0,0))
		{
			result+=abi::__cxa_demangle(string.c_str(),0,0,0);
			result+="\n";
		}
		else if(!string.empty())
		{
			result+="ERROR: ";
			result+=string;
			result+="\n";
		}
	}
	return env->NewStringUTF(result.c_str());
}

}
